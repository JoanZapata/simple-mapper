{"name":"Simple-mapper","tagline":"A very simple POJO mapper based on getters/setters with support for inheritance, cyclic dependencies, and hooks.","body":"# Simple Mapper \r\n> I created this library because I'm tired of big xml-based or annotation-based mapping frameworks when all I need is a **very basic mapping** between business objects and lightweight DTOs with a similar structure.\r\n\r\n**Simple Mapper** is a java objects mapper meant to be very easy-to-use and intuitive. It looks for setters in the destination object and try to find the corresponding getter in the source object. It manages ```cyclic dependencies```, ```inheritance```, and ```hooks```.\r\n\r\n# Get it\r\n\r\nSimple Mapper is **available in [Maven Central](http://search.maven.org/remotecontent?filepath=com/joanzapata/mapper/simple-mapper/1.0.8/simple-mapper-1.0.9.jar)**:\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>com.joanzapata.mapper</groupId>\r\n    <artifactId>simple-mapper</artifactId>\r\n    <version>1.0.9</version>\r\n</dependency>\r\n```\r\n\r\n# Basics\r\n\r\nYou do all the mapping with the ```Mapper``` object and its ```map()``` method.\r\n\r\n```java\r\n// First, create a ```Mapper``` object.\r\nMapper mapper = new Mapper();\r\n\r\n// Map a plain old java object with map()\r\nBookDTO bookDTO = mapper.map(book, BookDTO.class);\r\n\r\n// Mapper will detect lists and maps so you can do things like:\r\nList<BookDTO> bookListDTO = mapper.map(bookList, BookDTO.class);\r\nMap<Long, BookDTO> bookListDTO = mapper.map(bookMap, Long.class, BookDTO.class);\r\n```\r\n\r\n# Inheritance\r\n\r\nIf you need support for inheritance, you must provide the mappings of the subclasses:\r\n\r\n![Alt](https://raw.github.com/JoanZapata/simple-mapper/master/inheritance.png)\r\n\r\n```\r\nMapper mapper = new Mapper()\r\n    .mapping(B.class, B'.class)\r\n    .mapping(C.class, C'.class);\r\n```\r\n\r\n* You can register mapping in both directions by using the ```biMapping``` method.\r\n\r\n# Name binding\r\n\r\nThe mapper supports name variations, that means for example that ```public Book getBook()``` in the source object is considered as a valid candidate for ```public void setBookDTO(BookDTO bookDTO)``` in the destination object. The library currently manage ```DTO``` and ```BO``` name variations.\r\n\r\n# Hooks\r\n\r\nIf you need custom mapping or additional operations after some mappings, you can provide hooks:\r\n\r\n```java\r\nMapper mapper = new Mapper()\r\n    .hook(new Hook<BookEntry, BookEntryDTO>() {\r\n        @Override\r\n        public void extraMapping(BookEntry source, BookEntryDTO destination) {\r\n            // Do additional operations in the destination object\r\n        }\r\n    };\r\n});\r\n```\r\n\r\n* Hooks are called **after** the object has been fully mapped.\r\n* Hooks are guaranteed to be called in the **order** you added them to the mapper. \r\n\r\n# Custom Mapping\r\n\r\nIf you need to totally handle the mapping of certain types, you can provide custom mappers:\r\n\r\n```java\r\nMapper mapper = new Mapper()\r\n    .customMapper(new CustomMapper<PhoneEntry, PhoneEntryDTO>() {\r\n        @Override\r\n        public PhoneEntryDTO map(PhoneEntry source, MappingContext context) {\r\n            // Here you can create a PhoneEntryDTO by yourself and return it.\r\n            PhoneEntryDTO phoneEntryDTO = new PhoneEntryDTO();\r\n            phoneEntryDTO.setNumber(source.getNumber());\r\n            phoneEntryDTO.setName(source.getName());\r\n            return phoneEntryDTO;\r\n            \r\n            // You can also delegate it to another mapper, in this case don't\r\n            // forget to pass the mapping context along with the source:\r\n            return phoneEntryMapper.map(source, PhoneEntryDTO.class, context);\r\n        }\r\n    };\r\n});\r\n```\r\n\r\nIf you need to provide a custom mapping both ways, you can use a CustomBiMapper:\r\n\r\n```java\r\nMapper mapper = new Mapper()\r\n    .customBiMapper(new CustomBiMapper<PhoneEntry, PhoneEntryDTO>() {\r\n        @Override\r\n        public PhoneEntryDTO mapForward(PhoneEntry source, MappingContext context) {\r\n            // Mapping\r\n        }\r\n    \r\n        @Override\r\n        public PhoneEntry mapBackward(PhoneEntryDTO source, MappingContext context) {\r\n            // Mapping\r\n        }\r\n    };\r\n});\r\n```\r\n\r\n# Strict Mode\r\n\r\nThe simple-mapper is very permissive by default. If something wrong happens mapping a property, it gives up and goes to the next property to map. You can override this behavior by setting the ```StrictMode```. In this mode, the ```map()``` function will raise a ```StrictModeException``` if something goes wrong:\r\n* No getter found that matches a setter in the destination object.\r\n* Types mismatch between getter and setter.\r\n* Destination object doesn't have an empty constructor.\r\n* Any other bad thing happens during the mapping.\r\n\r\n```java\r\nMapper mapper = new Mapper().strictMode();\r\n```\r\n\r\n# License\r\n\r\n```\r\nCopyright 2013 Joan Zapata\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n```\r\n","google":"UA-41258927-1","note":"Don't delete this file! It's used internally to help with page regeneration."}